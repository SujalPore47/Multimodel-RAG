[
    {
        "time": "2024-09-27 13:49:46",
        "user_input": "who won ipl in 2024",
        "ai_response": "I do not have access to real-time information, including sports results.  To find out who won the IPL in 2024, you'll need to check a sports news website or official IPL website. \n"
    },
    {
        "time": "2024-09-27 13:50:12",
        "user_input": "who won ipl in 2024",
        "ai_response": "The Kolkata Knight Riders won the IPL in 2024."
    },
    {
        "time": "2024-09-27 13:51:32",
        "user_input": " Hello, tell me something about Sun.",
        "ai_response": "The Sun is a star, the center of our solar system. Here are some key facts about it:\n\n* **A giant ball of hot gas:** The Sun is primarily composed of hydrogen and helium, and it's incredibly hot, with a surface temperature of about 10,000 degrees Fahrenheit (5,500 degrees Celsius).\n* **Provides light and heat:** The Sun's energy is the source of light and heat for Earth, making life possible.\n* **Nuclear fusion:** The Sun's energy comes from nuclear fusion, where hydrogen atoms combine to form helium, releasing tremendous amounts of energy.\n* **Lifespan:**  The Sun is about halfway through its estimated 10-billion-year lifespan.\n* **Importance to Earth:** The Sun's gravitational pull keeps Earth in orbit, and its energy powers the Earth's climate, weather patterns, and life cycles. \n\nDo you have any specific questions about the Sun? I'd be happy to provide more information! \n"
    },
    {
        "time": "2024-09-27 13:52:21",
        "user_input": "tell me about alard college of engineering",
        "ai_response": "Alard College of Engineering and Management (ACEM) is located in Pune, India. It was established in 2009 and is affiliated with Savitribai Phule Pune University. ACEM is approved by the All India Council for Technical Education (AICTE) and offers undergraduate and postgraduate engineering programs. The college is known for its modern and sophisticated campus and is considered one of the best engineering colleges in Pune."
    },
    {
        "time": "2024-09-27 13:53:07",
        "user_input": "https://youtu.be/QQdiHrIc84o",
        "ai_response": "##  YouTube Video Summary: LangChain & Grok for End-to-End RAG Project \n\nThis video demonstrates building an end-to-end RAG (Retrieval Augmented Generation) project using LangChain, open-source LLMs, and the Grok inferencing engine. Here are the key takeaways:\n\n* **Grok Inferencing Engine:** Grok is a new inferencing engine that claims to be significantly faster than GPUs due to its LPU (Language Processing Unit) architecture. \n* **Open-Source LLMs:** The project utilizes open-source LLMs like  \"AMA embedding\" for embedding and \"Gamma 7B\" for the LLM model, emphasizing cost-effectiveness and accessibility.\n* **Web Scraping with LangChain:** LangChain's `WebBaseLoader` is used to scrape content from a chosen website (docs.langchain.com).\n* **Document Chunking:** `RecursiveCharacterTextSplitter` breaks down the scraped content into smaller chunks for better processing.\n* **Vector Store:**  The `FAISS` vector store is employed to store embeddings for efficient document retrieval.\n* **Streamlit for Web Application:** Streamlit is used to create a user-friendly web interface for interacting with the RAG project.\n* **Retrieval Chain:** LangChain's `create_retrieval_chain` combines document chain and retrieval to provide a unified interface for interacting with the vector store.\n* **Chat Prompt Template:** A custom `ChatPromptTemplate` is defined to guide the LLM in answering questions based on provided context.\n* **RAG Project Functionality:** The final project allows users to input questions and get relevant answers based on the content from the chosen website.\n\nThe video highlights the speed of Grok and showcases how to create a simple RAG project using open-source tools, providing a cost-effective solution for users. \n"
    },
    {
        "time": "2024-09-27 14:00:13",
        "user_input": " Tell me something about the CSV file.",
        "ai_response": "The CSV file contains 100 rows and 12 columns. It has one integer column ('Index') and eleven object columns. The memory usage is 9.5+ KB."
    },
    {
        "time": "2024-09-27 14:02:29",
        "user_input": "how can i host this code using streamlit : # Import necessary libraries\nfrom streamlit_mic_recorder import mic_recorder \nimport streamlit as st\nimport os\nfrom streamlit_chat import message\nfrom datetime import datetime\nimport json\nimport uuid\nimport google.generativeai as genai\nfrom dotenv import load_dotenv\nfrom csv_file_handling import CSVHandler  \nfrom pdf_file_handling import PDFHandler  \nfrom img_file_handling import IMGHandler  \nfrom search_the_web import SearchTheWeb\nfrom youtube_summariser import YoutubeSummariser\nfrom audio_handler import transcribe_audio\n####################################### Load environment variables ################################################################\nload_dotenv()\ngenai.configure(api_key=os.getenv(\"GOOGLE_API_KEY\"))\n###################################################################################################################################\n                                              #Main Function                             \n###################################################################################################################################\n\ndef main():\n    # Initialize handlers\n    csv_handler = CSVHandler()\n    pdf_handler = PDFHandler()\n    img_handler = IMGHandler()\n    web_search  = SearchTheWeb()\n    yt_summarise = YoutubeSummariser()\n    # Initialize session state for history\n    if 'history' not in st.session_state:\n        st.session_state['history'] = []\n###################################################################################################################################\n    # Function to handle conversation history\n    def load_history():\n        return st.session_state['history']\n\n    def save_history(history):\n        st.session_state['history'] = history\n###################################################################################################################################\n    # Function to generate AI response\n    def generate_response(history , user_input):\n        # Format history as a string\n        history_text = \"\\n\".join([f\"{entry['time']}: {entry['user_input']} \u2192 {entry['ai_response']}\" for entry in history])\n        # Combine history with user input\n        prompt = f\"{history_text}\\n{user_input}\\nAI:\"\n        llm_model = genai.GenerativeModel(\"gemini-1.5-flash\")\n        response = llm_model.generate_content(prompt)\n        return response.text if response else \"Error generating response.\"\n###################################################################################################################################\n\n    # Streamlit page configuration\n    st.set_page_config(page_title=\"Prototype\", layout=\"wide\")\n###################################################################################################################################\n\n    # Main title\n    st.title(\"Multi_Model ChatBot\")\n###################################################################################################################################\n\n    # Load conversation history\n    history = load_history()\n###################################################################################################################################\n\n    # Display chat messages from history\n    st.write(\"## Chat\")\n    for entry in history:\n        message(entry['user_input'], is_user=True, key=f\"user_{uuid.uuid4()}\")\n        message(entry['ai_response'], key=f\"ai_{uuid.uuid4()}\")\n###################################################################################################################################\n\n    # Sidebar for file uploads and management\n    st.sidebar.header(\"Functionalities\")\n###################################################################################################################################\n######################################### CSV file uploader and processing #########################################################\n    if csv_file := st.sidebar.file_uploader(\"Upload a CSV file\", type=\"csv\"):\n        if st.sidebar.button(\"Submit and Process CSV\"):\n            st.session_state['csv_bytes'] = csv_file.read()# Store CSV content in session state\n            st.sidebar.success(\"CSV file uploaded successfully!\")\n################################ Button to remove CSV data from session state #####################################################\n    if 'csv_bytes' in st.session_state and st.sidebar.button(\"Stop chatting with CSV file\"):\n        del st.session_state['csv_bytes']# Remove from session state\n        st.sidebar.info(\"CSV data removed. You are now chatting without the CSV context.\")\n###################################################################################################################################\n######################################### PDF file uploader and processing#########################################################\n    if pdf_file := st.sidebar.file_uploader(\"Upload a PDF file\", type=\"pdf\"):\n        if st.sidebar.button(\"Submit and Process PDF\"):\n            documents = pdf_handler.file_loader(pdf_file)  # Process PDF file\n            if documents:\n                st.session_state['pdf_documents'] = documents  # Store in session state\n                st.sidebar.success(\"PDF file processed successfully!\")\n            else:\n                st.sidebar.error(\"Error processing PDF.\")\n#################################### Button to remove PDF data from session state ####################################################\n    if 'pdf_documents' in st.session_state and st.sidebar.button(\"Stop chatting with PDF file\"):\n        del st.session_state['pdf_documents']\n        st.sidebar.info(\"PDF data removed. You are now chatting without the PDF context.\")\n######################################################################################################################################\n################################################ Image file uploader ##################################################################\n    if img_file := st.sidebar.file_uploader(\"Upload an image file\", type=[\"jpg\", \"jpeg\", \"png\"]):\n        if st.sidebar.button(\"Submit and Process IMG\"):\n            st.session_state['img_file'] = img_file  # Store image file in session state\n            st.sidebar.success(\"Image file uploaded successfully!\")\n################################### Button to remove image data from session state####################################################\n    if 'img_file' in st.session_state and st.sidebar.button(\"Stop chatting with Image file\"):\n        del st.session_state['img_file'] #Remove from sessions state\n        st.sidebar.info(\"Image data removed. You are now chatting without the image context.\")\n#####################################################################################################################################\n\n#####################################################################################################################################\n\n#End of side bar\n\n###################################################################################################################################\n\n################################################### Function to handle input , submit and search ##############################################\n    def handle_submit():\n        user_input = st.session_state.get('input_text', '')\n        if user_input:\n            # Check if CSV data is available for CSV-related queries\n            if 'csv_bytes' in st.session_state:\n                csv_bytes = st.session_state['csv_bytes']\n                ai_response = csv_handler.ask_csv_question(csv_bytes, user_input)\n            # Check if PDF data is available for PDF-related queries\n            elif 'pdf_documents' in st.session_state:\n                documents = st.session_state['pdf_documents']\n                ai_response = pdf_handler.get_qa_response(documents=documents, question=user_input)\n            # Check if Image data is available for Image-related queries\n            elif 'img_file' in st.session_state:\n                image_file = st.session_state['img_file']\n                template = \"\"\"You are a helpful AI assistant / image chatbot with extensive knowledge\n                            who helps the user to answer their queries using the image as reference.\n                            Answer:\"\"\"\n                ai_response = img_handler.get_gemini_response_without_tesseract(\n                    input_text=user_input, img_file=image_file, prompt=template\n                )\n            else:\n                # Generate AI response for general conversation\n                ai_response = generate_response(history=history, user_input=user_input)\n\n            # Update chat history\n            history.append({\"time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                            \"user_input\": user_input, \"ai_response\": ai_response})\n            save_history(history)\n\n            # Clear the input bar\n            st.session_state['input_text'] = \"\"\n###################################################################################################################################\n    def handle_search():\n        user_input = st.session_state.get('input_text', '')\n        if user_input:\n            # Check if CSV data is available for CSV-related queries\n            if 'csv_bytes' in st.session_state:\n                csv_bytes = st.session_state['csv_bytes']\n                ai_response = csv_handler.ask_csv_question(csv_bytes, user_input)\n            # Check if PDF data is available for PDF-related queries\n            elif 'pdf_documents' in st.session_state:\n                documents = st.session_state['pdf_documents']\n                ai_response = pdf_handler.get_qa_response(documents=documents, question=user_input)\n            # Check if Image data is available for Image-related queries\n            elif 'img_file' in st.session_state:\n                image_file = st.session_state['img_file']\n                template = \"\"\"You are a helpful AI assistant / image chatbot with extensive knowledge\n                            who helps the user to answer their queries using the image as reference.\n                            Answer:\"\"\"\n                ai_response = img_handler.get_gemini_response_without_tesseract(\n                    input_text=user_input, img_file=image_file, prompt=template\n                )\n            else:\n                # Generate AI response for general conversation\n                ai_response = web_search.websearch(user_input=user_input)\n\n            # Update chat history\n            history.append({\"time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                            \"user_input\": user_input, \"ai_response\": ai_response})\n            save_history(history)\n\n            # Clear the input bar\n            st.session_state['input_text'] = \"\"\n###################################################################################################################################\n    def handle_summarise():\n        user_input = st.session_state.get('input_text', '')\n        if user_input:\n            try:\n                # Define the prompt for the summarizer\n                prompt = \"\"\"You are a YouTube video summarizer. You will be taking the transcript text\n                and summarizing the entire video, providing the important summary in points within 250 words.\n                Please provide the summary of the text given here: \"\"\"\n\n                # Attempt to extract the transcript from the YouTube video\n                transcribe_text = yt_summarise.extract_transcript_details(youtube_video_url=user_input)\n\n                # Check if the transcript extraction returned an error message\n                if \"Invalid YouTube link\" in transcribe_text or \"Could not retrieve transcript\" in transcribe_text:\n                    st.error(transcribe_text)\n                    return\n\n                # If transcript extraction is successful, generate the summary\n                ai_response = yt_summarise.get_summary(prompt=prompt, yt_transcribe_text=transcribe_text)\n\n                # Check if summary generation returned an error message\n                if \"An error occurred while generating the summary\" in ai_response:\n                    st.error(ai_response)\n                    return\n\n                # Update chat history\n                history.append({\n                    \"time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    \"user_input\": user_input,\n                    \"ai_response\": ai_response\n                })\n                save_history(history)\n\n            except ValueError:\n                st.error(\"Please paste an appropriate YouTube link.\")\n            except Exception as e:\n                # Catch all other exceptions and print a user-friendly message\n                st.error(f\"An error occurred while processing the YouTube link. Please ensure the link is correct and try again.\")\n\n            finally:\n                # Clear the input bar regardless of success or failure\n                st.session_state['input_text'] = \"\"                \n###################################################################################################################################\n    def handle_audio():\n            if voice_recorder is not None:\n                audio_bytes = voice_recorder['bytes']                \n                # Transcribe audio bytes\n                audio_text = transcribe_audio(audio_bytes=audio_bytes)\n                if audio_text:\n                    st.session_state['audio_text'] = audio_text\n                    st.success(\"Successfully loaded the audio\")\n                    user_input = st.session_state['audio_text']                   \n                    # Process user input\n                    if user_input:\n                        if 'csv_bytes' in st.session_state:\n                            csv_bytes = st.session_state['csv_bytes']\n                            ai_response = csv_handler.ask_csv_question(csv_bytes, user_input)\n                        elif 'pdf_documents' in st.session_state:\n                            documents = st.session_state['pdf_documents']\n                            ai_response = pdf_handler.get_qa_response(documents=documents, question=user_input)\n                        elif 'img_file' in st.session_state:\n                            image_file = st.session_state['img_file']\n                            template = \"\"\"You are a helpful AI assistant / image chatbot with extensive knowledge\n                                        who helps the user to answer their queries using the image as reference.\n                                        Answer:\"\"\"\n                            ai_response = img_handler.get_gemini_response_without_tesseract(\n                                input_text=user_input, img_file=image_file, prompt=template\n                            )\n                        else:\n                            ai_response = generate_response(history=history, user_input=user_input)\n                        \n                        # Append to history and save\n                        history.append({\"time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                        \"user_input\": user_input, \"ai_response\": ai_response})\n                        save_history(history)\n                        \n                        # Clear the audio input\n                        st.session_state['audio_text'] = \"\"\n                    else:\n                        st.write(\"No input detected from the recorded audio.\")\n                else:\n                    st.write(\"No transcribed text detected from the audio.\")\n            else:\n                st.error(\"No audio data found. Please try recording again.\")\n\n\n    # Form to handle all the input operations\n    with st.form(key='chat_form', clear_on_submit=True):\n        user_input = st.text_area(\"Type your message...\", key=\"input_text\", height=50)\n        \n        # Create five columns for buttons\n        col1, col2, col3, col4 = st.columns([0.4, 0.8, 1, 1])\n        \n        with col1:\n            submit_button = st.form_submit_button(\"Send\", on_click=handle_submit)\n            \n        with col2:\n            search_button = st.form_submit_button(\"Search The Web\", on_click=handle_search)\n\n        with col3:\n            YT_button = st.form_submit_button(\"Summarise The Video\", on_click=handle_summarise) \n        \n        with col4:\n            audio_button = st.form_submit_button(\"Send_audio\", on_click=handle_audio)\n\n    voice_recorder = mic_recorder(start_prompt=\"Start recording\",stop_prompt=\"Stop recording\")\n\n###################################################################################################################################\n                                           #Handling Voice Input\n###################################################################################################################################\n\n###################################################################################################################################\n###################################################################################################################################\n    # Save conversation to a file button (Optional)\n    if st.sidebar.button(\"Save Chat\"):\n        with open(\"chat_history.json\", \"w\") as f:\n            json.dump(history, f, indent=4)\n        st.sidebar.success(\"Chat saved to chat_history.json\")\n###################################################################################################################################\nif __name__ == \"__main__\":\n    main()",
        "ai_response": "This code builds a sophisticated chatbot using Streamlit and integrates various functionalities:\n\n**Key Components:**\n\n1. **Streamlit UI:**  The foundation is Streamlit, a Python library that simplifies building web apps. It structures the layout, handles user input, and displays the chatbot's responses.\n\n2. **Google Gemini API:** This is the core AI engine powering the conversation. It utilizes the `google.generativeai` library to interact with the Gemini language model for text generation.\n\n3. **LangChain:**  LangChain is used for building the Retrieval Augmented Generation (RAG) part of the bot. It allows the bot to access and use external information.\n\n4. **File Uploads & Processing:**\n    - **CSV Handling:** The `CSVHandler` class processes CSV files and allows the bot to answer questions based on the data.\n    - **PDF Handling:** The `PDFHandler` class reads PDF files and provides a question-answering capability.\n    - **Image Handling:**  The `IMGHandler` class processes images and uses Gemini to answer questions related to the image.\n\n5. **Web Search:** The `SearchTheWeb` class allows the bot to search the web and provide results to the user.\n\n6. **YouTube Summarization:** The `YoutubeSummariser` class takes a YouTube URL, extracts the transcript, and provides a concise summary using Gemini.\n\n7. **Audio Transcription:** The `transcribe_audio` function uses Google Cloud Speech-to-Text to convert recorded audio into text.\n\n**How it Works:**\n\n1. **User Interface:** The code sets up the Streamlit app with a chat area and a sidebar. The sidebar provides options to upload files (CSV, PDF, Image) and interact with the bot.\n\n2. **File Processing:** When a user uploads a file, the relevant handler processes it and stores the information in the session state. \n\n3. **Chat Interaction:**\n   - Users type messages into a text area.\n   - The code determines if there is relevant context from uploaded files.\n   - If not, it uses Gemini to generate a response based on the chat history.\n\n4. **Specific Functionality:**\n   - **CSV:**  The code uses the `CSVHandler` to answer questions based on the CSV data.\n   - **PDF:**  The `PDFHandler` is used to answer questions based on the PDF content.\n   - **Image:** The `IMGHandler` utilizes Gemini to understand the image and answer questions related to it.\n   - **Web Search:** The `SearchTheWeb` class searches the web and presents relevant results.\n   - **YouTube Summarization:** The `YoutubeSummariser` extracts the transcript and provides a summary.\n   - **Audio:** The code uses the `mic_recorder` component for recording audio. It then transcribes the audio using `transcribe_audio` and processes the text.\n\n5. **History:** The code maintains a chat history, which is displayed and used for context in future responses.\n\n**Hosting:**\n\nThis Streamlit code can be hosted in several ways:\n\n- **Streamlit Sharing:**  Streamlit Sharing is the easiest option. It's free for basic usage.\n- **Heroku:**  Heroku is a popular platform for deploying web apps. \n- **AWS:** AWS provides various services like Elastic Beanstalk, EC2, and Lambda for hosting.\n\n**Important Notes:**\n\n- **Environment Variables:** Ensure you have a `.env` file with the `GOOGLE_API_KEY` set to your Google Cloud project API key.\n- **Dependencies:** Install all necessary libraries using `pip install -r requirements.txt`.\n- **Permissions:** Ensure the code has the necessary permissions for file access, audio recording, and internet access.\n\nThis is a well-structured and complex chatbot. Let me know if you have any specific questions about the code or its functionalities. \n"
    },
    {
        "time": "2024-09-27 14:06:58",
        "user_input": "mala sang bhai tu image badal",
        "ai_response": "I am sorry, I cannot see or analyze any image. I am a text-based chat assistant and thus I cannot process any image."
    },
    {
        "time": "2024-09-27 14:07:28",
        "user_input": "tell me saomthing about the image",
        "ai_response": "The image shows a field of sunflowers. The sunflowers are in various stages of bloom, with some fully open and others still in bud. The sunflowers are all facing the sun, which is shining brightly in the background. The image is taken from a low angle, which gives the viewer a sense of being surrounded by the sunflowers. The image is warm and inviting, and it conveys a sense of peace and tranquility."
    },
    {
        "time": "2024-09-27 14:07:56",
        "user_input": "can u predict how many sunflowers are there in the image",
        "ai_response": "There are many sunflowers in this image, it is difficult to count them all but it seems like there are at least 30 sunflowers."
    }
]